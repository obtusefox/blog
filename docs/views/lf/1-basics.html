<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Logical Foundations 1. Basics | obtuseCave</title>
    <meta name="description" content="How data and functions are defined in Coq, and how you can prove theorems about them.">
    <link rel="icon" href="/blog/favicon.ico">
  <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    
    <link rel="preload" href="/blog/assets/css/0.styles.6fd52174.css" as="style"><link rel="preload" href="/blog/assets/js/app.4f221293.js" as="script"><link rel="preload" href="/blog/assets/js/5.caf4d2c7.js" as="script"><link rel="preload" href="/blog/assets/js/2.7734f288.js" as="script"><link rel="preload" href="/blog/assets/js/1.d3487e4a.js" as="script"><link rel="preload" href="/blog/assets/js/18.5b122441.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.655a952c.js"><link rel="prefetch" href="/blog/assets/js/11.4c35c23a.js"><link rel="prefetch" href="/blog/assets/js/12.aaa57a49.js"><link rel="prefetch" href="/blog/assets/js/13.a08d51bb.js"><link rel="prefetch" href="/blog/assets/js/14.d027f563.js"><link rel="prefetch" href="/blog/assets/js/15.3ef5aaae.js"><link rel="prefetch" href="/blog/assets/js/16.d6b73e66.js"><link rel="prefetch" href="/blog/assets/js/17.cd1a2dc4.js"><link rel="prefetch" href="/blog/assets/js/19.ee6bb86d.js"><link rel="prefetch" href="/blog/assets/js/20.8da19f38.js"><link rel="prefetch" href="/blog/assets/js/21.b5afba93.js"><link rel="prefetch" href="/blog/assets/js/22.2e20f54a.js"><link rel="prefetch" href="/blog/assets/js/23.d453bf25.js"><link rel="prefetch" href="/blog/assets/js/24.476b65ca.js"><link rel="prefetch" href="/blog/assets/js/25.c89a3b2b.js"><link rel="prefetch" href="/blog/assets/js/26.a93abbb0.js"><link rel="prefetch" href="/blog/assets/js/6.1b9e71b7.js"><link rel="prefetch" href="/blog/assets/js/7.2741631a.js"><link rel="prefetch" href="/blog/assets/js/8.6678c3cd.js"><link rel="prefetch" href="/blog/assets/js/9.b15ec0a3.js"><link rel="prefetch" href="/blog/assets/js/vendors~flowchart.59044e7b.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.6fd52174.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div><div class="theme-container"><div><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><img src="/blog/head.png" alt="obtuseCave" class="logo"> <span class="site-name">obtuseCave</span></a> <div class="links"><div class="color-picker"><a href="#" class="color-button"><i class="iconfont component-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="theme-options"><!----> <div class="dark-theme-options toggle-option"><label for="dark-theme-toggle">Enable Dark Theme?</label> <input id="dark-theme-toggle" type="checkbox" checked="checked"></div></div></div></div> <div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link"><i class="iconfont component-home"></i>
  Home
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont component-category"></i>
      Category
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/category/webDev.html" class="nav-link"><i class="iconfont undefined"></i>
  webDev
</a></li><li class="dropdown-item"><!----> <a href="/blog/category/essays.html" class="nav-link"><i class="iconfont undefined"></i>
  essays
</a></li><li class="dropdown-item"><!----> <a href="/blog/category/LF.html" class="nav-link"><i class="iconfont undefined"></i>
  LF
</a></li><li class="dropdown-item"><!----> <a href="/blog/category/PLF.html" class="nav-link"><i class="iconfont undefined"></i>
  PLF
</a></li><li class="dropdown-item"><!----> <a href="/blog/category/VST.html" class="nav-link"><i class="iconfont undefined"></i>
  VST
</a></li></ul></div></div><div class="nav-item"><a href="/blog/tag/" class="nav-link"><i class="iconfont component-tag"></i>
  Tag
</a></div><div class="nav-item"><a href="/blog/timeLine/" class="nav-link"><i class="iconfont component-date"></i>
  TimeLine
</a></div><div class="nav-item"><a href="https://github.com/han-minhee" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont component-github"></i>
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link"><i class="iconfont component-home"></i>
  Home
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont component-category"></i>
      Category
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/category/webDev.html" class="nav-link"><i class="iconfont undefined"></i>
  webDev
</a></li><li class="dropdown-item"><!----> <a href="/blog/category/essays.html" class="nav-link"><i class="iconfont undefined"></i>
  essays
</a></li><li class="dropdown-item"><!----> <a href="/blog/category/LF.html" class="nav-link"><i class="iconfont undefined"></i>
  LF
</a></li><li class="dropdown-item"><!----> <a href="/blog/category/PLF.html" class="nav-link"><i class="iconfont undefined"></i>
  PLF
</a></li><li class="dropdown-item"><!----> <a href="/blog/category/VST.html" class="nav-link"><i class="iconfont undefined"></i>
  VST
</a></li></ul></div></div><div class="nav-item"><a href="/blog/tag/" class="nav-link"><i class="iconfont component-tag"></i>
  Tag
</a></div><div class="nav-item"><a href="/blog/timeLine/" class="nav-link"><i class="iconfont component-date"></i>
  TimeLine
</a></div><div class="nav-item"><a href="https://github.com/han-minhee" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont component-github"></i>
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Logical Foundations 1. Basics</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/lf/1-basics.html#functional-programming" class="sidebar-link">Functional Programming</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog/views/lf/1-basics.html#enumerated-types" class="sidebar-link">Enumerated Types</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog/views/lf/1-basics.html#bool-type" class="sidebar-link">bool Type</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/views/lf/1-basics.html#bool-definition" class="sidebar-link">bool Definition</a></li><li class="sidebar-sub-header"><a href="/blog/views/lf/1-basics.html#function-definitions" class="sidebar-link">Function Definitions</a></li><li class="sidebar-sub-header"><a href="/blog/views/lf/1-basics.html#proofs-of-basic-facts" class="sidebar-link">Proofs of Basic Facts</a></li><li class="sidebar-sub-header"><a href="/blog/views/lf/1-basics.html#notaion" class="sidebar-link">Notaion</a></li><li class="sidebar-sub-header"><a href="/blog/views/lf/1-basics.html#first-exercise" class="sidebar-link">First Exercise</a></li></ul></li><li><a href="/blog/views/lf/1-basics.html#more-on-types" class="sidebar-link">More on Types</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/views/lf/1-basics.html#checking-types" class="sidebar-link">Checking Types</a></li><li class="sidebar-sub-header"><a href="/blog/views/lf/1-basics.html#compound-types" class="sidebar-link">Compound Types</a></li></ul></li><li><a href="/blog/views/lf/1-basics.html#numbers-module" class="sidebar-link">Numbers Module</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/views/lf/1-basics.html#numbers-type-정의" class="sidebar-link">Numbers type 정의</a></li><li class="sidebar-sub-header"><a href="/blog/views/lf/1-basics.html#numbers-함수" class="sidebar-link">Numbers 함수</a></li><li class="sidebar-sub-header"><a href="/blog/views/lf/1-basics.html#fixpoint" class="sidebar-link">Fixpoint</a></li><li class="sidebar-sub-header"><a href="/blog/views/lf/1-basics.html#notaion에-관해" class="sidebar-link">Notaion에 관해</a></li></ul></li><li><a href="/blog/views/lf/1-basics.html#간단한-증명" class="sidebar-link">간단한 증명</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/views/lf/1-basics.html#앞서-보았던-proof" class="sidebar-link">앞서 보았던 Proof</a></li><li class="sidebar-sub-header"><a href="/blog/views/lf/1-basics.html#rewrite를-써서-전제를-도입하는-증명" class="sidebar-link">rewrite를 써서 전제를 도입하는 증명</a></li><li class="sidebar-sub-header"><a href="/blog/views/lf/1-basics.html#destruct를-써서-case를-나누는-증명" class="sidebar-link">destruct를 써서 case를 나누는 증명</a></li></ul></li></ul></section></li></ul> </aside> <div><main class="page component-hide"> <div class="page-title"><h1>Logical Foundations 1. Basics</h1> <hr> <div data-v-8b5eec8a><i class="iconfont component-account" data-v-8b5eec8a><span data-v-8b5eec8a>Han, Minhee</span></i> <i class="iconfont component-date" data-v-8b5eec8a><span data-v-8b5eec8a>3/22/2019</span></i> <!----> <i class="iconfont component-tag tags" data-v-8b5eec8a><span class="tag-item" data-v-8b5eec8a>
      SF
    </span><span class="tag-item" data-v-8b5eec8a>
      PL
    </span><span class="tag-item" data-v-8b5eec8a>
      Coq
    </span></i></div></div> <div class="content__default"><h1 id="basics-of-coq"><a href="#basics-of-coq" aria-hidden="true" class="header-anchor">#</a> Basics of Coq</h1> <p>I'm writing these articles as my studying materials, and these will be a kind of rewriting the textbook in a easy, and more explained (or sometimes more concise) way. So I would recommend you to follow the original book, but this one might be helpful if you want to quickly skim or review what you've learned, this might be helpful.</p> <h2 id="functional-programming"><a href="#functional-programming" aria-hidden="true" class="header-anchor">#</a> Functional Programming</h2> <p>Coq is &quot;functional,&quot; in a way that you can only care about how the program works and what values they return. Based on this, you can make formal proofs and sound reasonings about program, or some mathematical thesis.</p> <p>Another way it is &quot;fuctional&quot; is that it emphasizes the use of functions. Functions are used like any other objects. For example, a function can take other function as its input, and return another function.</p> <p>Common featurs of functional languages is that they provide <strong>pattern matching</strong> and <strong>algebraic data types</strong>. Often, functions return different values based on the pattern of the input.</p> <p>We will begin by looking at <strong>Gallina</strong>, Coq's functional language, and after that, we will look at the tactics we can use.</p> <h2 id="enumerated-types"><a href="#enumerated-types" aria-hidden="true" class="header-anchor">#</a> Enumerated Types</h2> <p>Coq itself provides small set of built-in features. They don't have <code>bool</code> or <code>int</code> type. Instead, they provide powerful features to declare our own types.</p> <p>Enumerated Types are types that don't require any parameters to compose its types. They are just &quot;enumerated.&quot;</p> <div class="language-ocaml line-numbers-mode"><pre class="language-ocaml"><code>Inductive day <span class="token punctuation">:</span> Type <span class="token operator">:=</span>
  <span class="token operator">|</span> monday <span class="token punctuation">:</span> day
  <span class="token operator">|</span> tuesday <span class="token punctuation">:</span> day
  <span class="token operator">|</span> wednesday <span class="token punctuation">:</span> day
  <span class="token operator">|</span> thursday <span class="token punctuation">:</span> day
  <span class="token operator">|</span> friday <span class="token punctuation">:</span> day
  <span class="token operator">|</span> saturday <span class="token punctuation">:</span> day
  <span class="token operator">|</span> sunday <span class="token punctuation">:</span> day<span class="token punctuation">.</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>Above Codes define an enumerated type, <code>day</code>. It's elements are each day of a week. And in this case, return types are explicitly defined, but they can often be left ommitted. For a defined type, you can also define a new function.</p> <div class="language-ocaml line-numbers-mode"><pre class="language-ocaml"><code>Definition next<span class="token punctuation">_</span>weekday <span class="token punctuation">(</span>d<span class="token punctuation">:</span>day<span class="token punctuation">)</span> <span class="token punctuation">:</span> day <span class="token operator">:=</span>
  <span class="token keyword">match</span> d <span class="token keyword">with</span>
  <span class="token operator">|</span> monday    <span class="token operator">=&gt;</span> tuesday
  <span class="token operator">|</span> tuesday   <span class="token operator">=&gt;</span> wednesday
  <span class="token operator">|</span> wednesday <span class="token operator">=&gt;</span> thursday
  <span class="token operator">|</span> thursday  <span class="token operator">=&gt;</span> friday
  <span class="token operator">|</span> friday    <span class="token operator">=&gt;</span> monday
  <span class="token operator">|</span> saturday  <span class="token operator">=&gt;</span> monday
  <span class="token operator">|</span> sunday    <span class="token operator">=&gt;</span> monday
  <span class="token keyword">end</span><span class="token punctuation">.</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>Above function <code>next_week</code> takes a <code>day</code> typed datum as an input and returns a <code>day</code> typed value. It works based on the type of the input. This is one typical example of how <strong>pattern matching</strong> works.</p> <div class="language-ocaml line-numbers-mode"><pre class="language-ocaml"><code>Compute <span class="token punctuation">(</span>next<span class="token punctuation">_</span>weekday friday<span class="token punctuation">)</span><span class="token punctuation">.</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>You can run the above code to evaluate the code.</p> <div class="language-ocaml line-numbers-mode"><pre class="language-ocaml"><code>     <span class="token operator">=</span> monday
     <span class="token punctuation">:</span> day
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>You will get the result and the type of the evaluation. We will try checking some facts about the defined function.</p> <div class="language-ocaml line-numbers-mode"><pre class="language-ocaml"><code>Example test<span class="token punctuation">_</span>next<span class="token punctuation">_</span>weekday<span class="token punctuation">:</span>
  <span class="token punctuation">(</span>next<span class="token punctuation">_</span>weekday <span class="token punctuation">(</span>next<span class="token punctuation">_</span>weekday saturday<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> tuesday<span class="token punctuation">.</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>This declaration does two things: it makes an assertion and give it a name. It's assertion is that the next_weekday of the next_weekday of saturday is tuesday. We can just let them admitted, or prove them.</p> <div class="language-ocaml line-numbers-mode"><pre class="language-ocaml"><code>Proof<span class="token punctuation">.</span> simpl<span class="token punctuation">.</span> reflexivity<span class="token punctuation">.</span>  Qed<span class="token punctuation">.</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>In the proof, you can simplify, or evaluate each sides of the equation using <code>simpl</code> command, and if the resulting equation has same value on each sides, you can use <code>reflexivity</code> to eleminate them.</p> <h2 id="bool-type"><a href="#bool-type" aria-hidden="true" class="header-anchor">#</a> bool Type</h2> <p>Next, we will try to define boolean type in a familiar way. There are standard libraries containining simple types like this, of course, and you can just use them out of the box. But we will try to see how they are defined.</p> <h3 id="bool-definition"><a href="#bool-definition" aria-hidden="true" class="header-anchor">#</a> bool Definition</h3> <div class="language-ocaml line-numbers-mode"><pre class="language-ocaml"><code>Inductive bool <span class="token punctuation">:</span> Type <span class="token operator">:=</span>
  <span class="token operator">|</span> <span class="token boolean">true</span> <span class="token punctuation">:</span> bool
  <span class="token operator">|</span> <span class="token boolean">false</span> <span class="token punctuation">:</span> bool<span class="token punctuation">.</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="function-definitions"><a href="#function-definitions" aria-hidden="true" class="header-anchor">#</a> Function Definitions</h3> <div class="language-ocaml line-numbers-mode"><pre class="language-ocaml"><code>Definition negb <span class="token punctuation">(</span>b<span class="token punctuation">:</span>bool<span class="token punctuation">)</span> <span class="token punctuation">:</span> bool <span class="token operator">:=</span>
  <span class="token keyword">match</span> b <span class="token keyword">with</span>
  <span class="token operator">|</span> <span class="token boolean">true</span> <span class="token operator">=&gt;</span> <span class="token boolean">false</span>
  <span class="token operator">|</span> <span class="token boolean">false</span> <span class="token operator">=&gt;</span> <span class="token boolean">true</span>
  <span class="token keyword">end</span><span class="token punctuation">.</span>

Definition andb <span class="token punctuation">(</span>b1<span class="token punctuation">:</span>bool<span class="token punctuation">)</span> <span class="token punctuation">(</span>b2<span class="token punctuation">:</span>bool<span class="token punctuation">)</span> <span class="token punctuation">:</span> bool <span class="token operator">:=</span>
  <span class="token keyword">match</span> b1 <span class="token keyword">with</span>
  <span class="token operator">|</span> <span class="token boolean">true</span> <span class="token operator">=&gt;</span> b2
  <span class="token operator">|</span> <span class="token boolean">false</span> <span class="token operator">=&gt;</span> <span class="token boolean">false</span>
  <span class="token keyword">end</span><span class="token punctuation">.</span>

Definition orb <span class="token punctuation">(</span>b1<span class="token punctuation">:</span>bool<span class="token punctuation">)</span> <span class="token punctuation">(</span>b2<span class="token punctuation">:</span>bool<span class="token punctuation">)</span> <span class="token punctuation">:</span> bool <span class="token operator">:=</span>
  <span class="token keyword">match</span> b1 <span class="token keyword">with</span>
  <span class="token operator">|</span> <span class="token boolean">true</span> <span class="token operator">=&gt;</span> <span class="token boolean">true</span>
  <span class="token operator">|</span> <span class="token boolean">false</span> <span class="token operator">=&gt;</span> b2
  <span class="token keyword">end</span><span class="token punctuation">.</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>You would understand how they are defined just by looking at them. Last two ones are different in that take two parameters instead of just one.</p> <h3 id="proofs-of-basic-facts"><a href="#proofs-of-basic-facts" aria-hidden="true" class="header-anchor">#</a> Proofs of Basic Facts</h3> <div class="language-ocaml line-numbers-mode"><pre class="language-ocaml"><code>Example test<span class="token punctuation">_</span>orb1<span class="token punctuation">:</span>  <span class="token punctuation">(</span>orb <span class="token boolean">true</span>  <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">.</span>
Proof<span class="token punctuation">.</span> simpl<span class="token punctuation">.</span> reflexivity<span class="token punctuation">.</span>  Qed<span class="token punctuation">.</span>
Example test<span class="token punctuation">_</span>orb2<span class="token punctuation">:</span>  <span class="token punctuation">(</span>orb <span class="token boolean">false</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">.</span>
Proof<span class="token punctuation">.</span> simpl<span class="token punctuation">.</span> reflexivity<span class="token punctuation">.</span>  Qed<span class="token punctuation">.</span>
Example test<span class="token punctuation">_</span>orb3<span class="token punctuation">:</span>  <span class="token punctuation">(</span>orb <span class="token boolean">false</span> <span class="token boolean">true</span><span class="token punctuation">)</span>  <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">.</span>
Proof<span class="token punctuation">.</span> simpl<span class="token punctuation">.</span> reflexivity<span class="token punctuation">.</span>  Qed<span class="token punctuation">.</span>
Example test<span class="token punctuation">_</span>orb4<span class="token punctuation">:</span>  <span class="token punctuation">(</span>orb <span class="token boolean">true</span>  <span class="token boolean">true</span><span class="token punctuation">)</span>  <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">.</span>
Proof<span class="token punctuation">.</span> simpl<span class="token punctuation">.</span> reflexivity<span class="token punctuation">.</span>  Qed<span class="token punctuation">.</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>Proofs are pretty simple till now.</p> <h3 id="notaion"><a href="#notaion" aria-hidden="true" class="header-anchor">#</a> Notaion</h3> <div class="language-ocaml line-numbers-mode"><pre class="language-ocaml"><code>Notation <span class="token string">&quot;x &amp;&amp; y&quot;</span> <span class="token operator">:=</span> <span class="token punctuation">(</span>andb x y<span class="token punctuation">)</span><span class="token punctuation">.</span>
Notation <span class="token string">&quot;x || y&quot;</span> <span class="token operator">:=</span> <span class="token punctuation">(</span>orb x y<span class="token punctuation">)</span><span class="token punctuation">.</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Like this, you can assign a notation to a defined functions or data.</p> <div class="language-ocaml line-numbers-mode"><pre class="language-ocaml"><code>Example test<span class="token punctuation">_</span>orb5<span class="token punctuation">:</span>  <span class="token boolean">false</span> <span class="token operator">||</span> <span class="token boolean">false</span> <span class="token operator">||</span> <span class="token boolean">true</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">.</span>
Proof<span class="token punctuation">.</span> simpl<span class="token punctuation">.</span> reflexivity<span class="token punctuation">.</span> Qed<span class="token punctuation">.</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>After the assignment, you can use the new notation, like above.</p> <h3 id="first-exercise"><a href="#first-exercise" aria-hidden="true" class="header-anchor">#</a> First Exercise</h3> <p>The textbook warns not to explicitly post the answer on the web, so I will put just some of them which require some explanations or ones that I had hard time solving them. For <code>Basics.v,</code> I think no explanation will be needed. Try to fill them up by looking at the codes above. My one advice is to reuse the theorems or definitions to make them simpler.</p> <h2 id="more-on-types"><a href="#more-on-types" aria-hidden="true" class="header-anchor">#</a> More on Types</h2> <p>Like what we've done, we can gradually define more complex types and definitions.</p> <h3 id="checking-types"><a href="#checking-types" aria-hidden="true" class="header-anchor">#</a> Checking Types</h3> <div class="language-ocaml line-numbers-mode"><pre class="language-ocaml"><code>Check <span class="token boolean">true</span><span class="token punctuation">.</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>You can check the type by using <code>Check</code>. For above,</p> <div class="language-ocaml line-numbers-mode"><pre class="language-ocaml"><code><span class="token boolean">true</span>
     <span class="token punctuation">:</span> bool
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Will be displyed.</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Check negb.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>Likewise, for a function,</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>negb
     : bool -&gt; bool
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>input and output types will be defined.</p> <h3 id="compound-types"><a href="#compound-types" aria-hidden="true" class="header-anchor">#</a> Compound Types</h3> <p>So far, types we looked at were enumerated types, which their constructors themselves become types. Now, we will look at types made by taking an argument or arguments.</p> <div class="language-ocaml line-numbers-mode"><pre class="language-ocaml"><code>Inductive rgb <span class="token punctuation">:</span> Type <span class="token operator">:=</span>
  <span class="token operator">|</span> red <span class="token punctuation">:</span> rgb
  <span class="token operator">|</span> green <span class="token punctuation">:</span> rgb
  <span class="token operator">|</span> blue <span class="token punctuation">:</span> rgb<span class="token punctuation">.</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>These are enumerated types as usual.</p> <div class="language-ocaml line-numbers-mode"><pre class="language-ocaml"><code>Inductive color <span class="token punctuation">:</span> Type <span class="token operator">:=</span>
  <span class="token operator">|</span> black <span class="token punctuation">:</span> color
  <span class="token operator">|</span> white <span class="token punctuation">:</span> color
  <span class="token operator">|</span> primary <span class="token punctuation">:</span> rgb <span class="token operator">-&gt;</span> color<span class="token punctuation">.</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>Then, we can define a new type named <code>color</code>, which additionally has a compound type constructor.</p> <div class="language-ocaml line-numbers-mode"><pre class="language-ocaml"><code>Definition monochrome <span class="token punctuation">(</span>c <span class="token punctuation">:</span> color<span class="token punctuation">)</span> <span class="token punctuation">:</span> bool <span class="token operator">:=</span>
  <span class="token keyword">match</span> c <span class="token keyword">with</span>
  <span class="token operator">|</span> black <span class="token operator">=&gt;</span> <span class="token boolean">true</span>
  <span class="token operator">|</span> white <span class="token operator">=&gt;</span> <span class="token boolean">true</span>
  <span class="token operator">|</span> primary p <span class="token operator">=&gt;</span> <span class="token boolean">false</span>
  <span class="token keyword">end</span><span class="token punctuation">.</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><div class="language-ocaml line-numbers-mode"><pre class="language-ocaml"><code>Definition isred <span class="token punctuation">(</span>c <span class="token punctuation">:</span> color<span class="token punctuation">)</span> <span class="token punctuation">:</span> bool <span class="token operator">:=</span>
  <span class="token keyword">match</span> c <span class="token keyword">with</span>
  <span class="token operator">|</span> black <span class="token operator">=&gt;</span> <span class="token boolean">false</span>
  <span class="token operator">|</span> white <span class="token operator">=&gt;</span> <span class="token boolean">false</span>
  <span class="token operator">|</span> primary red <span class="token operator">=&gt;</span> <span class="token boolean">true</span>
  <span class="token operator">|</span> primary <span class="token punctuation">_</span> <span class="token operator">=&gt;</span> <span class="token boolean">false</span>
  <span class="token keyword">end</span><span class="token punctuation">.</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="numbers-module"><a href="#numbers-module" aria-hidden="true" class="header-anchor">#</a> Numbers Module</h2> <p>Coq에서는, 다른 언어와 마찬가지로, 모듈 시스템을 제공한다. 우리는 자연수 타입 선언과 그와 관련된 함수들을 Module로 만들어보도록 하자. <code>Module X</code>로 시작하여, 중간에 해당 모듈에 들어갈 타입 정의를 적고, <code>End X</code>로 끝내준다.</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Module NatPlayground.
... [ 여기에 코드를 입력 ]
End NatPlayground.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="numbers-type-정의"><a href="#numbers-type-정의" aria-hidden="true" class="header-anchor">#</a> Numbers type 정의</h3> <p>이제 그 내부를 채워보자. 마치 Nil과 Cons로 리스트 타입을 정의하던 것처럼,</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Inductive nat : Type :=
  | O : nat
  | S : nat -&gt; nat.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>O로, Nil처럼 0을 정의하고, S로, Cons처럼 그에 1씩 더해짐을 표현해보자. <code>S(O)</code>는 1, <code>S(S(O))</code>는 2... 그럼 우리는 숫자를 표현하는 방법, representation까지를 만든 셈이다.
이것은 단순히 표기의 문제일 뿐이니,</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Inductive nat' : Type :=
  | stop : nat'
  | tick : nat' -&gt; nat'.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>와 같이 적어도 무방하다. 이름만 다르지 같은 데이터 구조를 나타내기 때문.</p> <h3 id="numbers-함수"><a href="#numbers-함수" aria-hidden="true" class="header-anchor">#</a> Numbers 함수</h3> <p>그럼 함수를 만들어보자. nat type의 n에 대해, 그 predecessor를 반환하는 pred함수.</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Definition pred (n : nat) : nat :=
  match n with
    | O =&gt; O
    | S n' =&gt; n'
  end.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>일단 O에 대해서는 predecessor가 O라고 정하자. 그럼 O에 대해서는 O를 반환하고, 그보다 큰 어떠한 S(n')에 대해서는 n'을 반환한다. 이렇게 numbers 타입들을 정의해보았다.
그런데 coq는 자동으로 데이터 타입을 내부적으로 숫자로 변환하기도 한다.</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Check (S (S (S (S O)))).
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>을 확인하면</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  4 : nat
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>값이 반환된다. 자동으로 constructor들을 정의해준 것을 알 수 있다.
이제 이 숫자값에 대해, pred와 유사하게 minustwo 함수를 정의해보자. 우리는 음수 타입을 정의하지 않았으므로, 음수값에 대해서는 O를 반환하자.</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Definition minustwo (n : nat) : nat :=
  match n with
    | O =&gt; O
    | S O =&gt; O
    | S (S n') =&gt; n'
  end.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>으로 정의하고</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Compute (minustwo 4).
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>계산해보면, <code>2: nat</code> 값을 반환한다. 증명 과정에선 compute 대신 simpl.을 사용하여 evaluate할 수 있다.</p> <h3 id="fixpoint"><a href="#fixpoint" aria-hidden="true" class="header-anchor">#</a> Fixpoint</h3> <p>앞서 정의한 함수들은 사실 간단한 경우들이다. 그런데 실제로 무언가 유용하거나 좀 더 복잡한 함수를 만들기 위해서는 단순히 각 타입에 대해 한 번에 evaluation이 끝나는 것이 아니라, recursion이 필요한 경우가 있다. 이런 타입에 대해서는 Fixpoint로 함수 선언을 한다.
인자로 주어진 값이 짝수인지를 판별하는 함수를 선언해보자.</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Fixpoint evenb (n:nat) : bool :=
  match n with
  | O        =&gt; true
  | S O      =&gt; false
  | S (S n') =&gt; evenb n'
  end.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>0, 1의 경우에는 앞서 정의한 바와 같이 정의가 되지만 그보다 큰 수에 대해서는 재귀적으로 함수 정의를 하게 된다. <code>S (S n')</code>의 경우, 다시 적자면 <code>1 + 1 + n'</code>의 경우는 <code>n'</code>이 짝수인지를 evaluate하여 반환한다.
비슷한 방식으로 두 자연수를 더하는 plus 함수를 정의해보자.</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Fixpoint plus (n : nat) (m : nat) : nat :=
  match n with
    | O =&gt; m
    | S n' =&gt; S (plus n' m)
  end.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>이를 바탕으로 mult 함수까지 정의해보자. 여러 인자가 같은 타입인 경우 한 번에 타입 선언을 할 수 있다.</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Fixpoint mult (n m : nat) : nat :=
  match n with
    | O =&gt; O
    | S n' =&gt; plus m (mult n' m)
  end.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>혹은, 여러 인자를 한 번에 <code>,</code>로 구분하여 case matching을 할 수 있다. 대해, 다른 인자의 값이 상관 없는 경우 case matching에서 상관 없는 인자를 <code>_</code>로 적을 수 있다.</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Fixpoint minus (n m:nat) : nat :=
  match n, m with
  | O   , _    =&gt; O
  | S _ , O    =&gt; n
  | S n', S m' =&gt; minus n' m'
  end.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>이 또한 함수형 프로그램에서 익숙한 convention이다. 이상으로 number type에 대한 간략한 예제를 마친다. 추가적인 exercise는 boolean 예제보단 조금씩 머리를 쓰긴 해야 하지만, 마찬가지로 그렇게 어렵진 않다.</p> <h3 id="notaion에-관해"><a href="#notaion에-관해" aria-hidden="true" class="header-anchor">#</a> Notaion에 관해</h3> <p>위에서 하던 대로 notation을 적용하자. 그런데 위와 달리 at level, associativity 같은 개념이 추가된다.</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Notation &quot;x + y&quot; := (plus x y)
                       (at level 50, left associativity)
                       : nat_scope.
Notation &quot;x - y&quot; := (minus x y)
                       (at level 50, left associativity)
                       : nat_scope.
Notation &quot;x * y&quot; := (mult x y)
                       (at level 40, left associativity)
                       : nat_scope.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>나중에 더 보겠지만, at level은 우선순위를 뜻한다.
associativity는 계산이 어느 방향으로 associative한지를 표현한다.
이에 대해서는 추후 더 자세히 다루도록 한다. &quot;More on Notaion&quot;에서.</p> <h2 id="간단한-증명"><a href="#간단한-증명" aria-hidden="true" class="header-anchor">#</a> 간단한 증명</h2> <p>간단한 증명의 방법을 알아보자.</p> <h3 id="앞서-보았던-proof"><a href="#앞서-보았던-proof" aria-hidden="true" class="header-anchor">#</a> 앞서 보았던 Proof</h3> <p>사실 simpl.에 의한 증명은 앞에서 본 바 있다.</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Example test_mult1: (mult 3 3) = 9.
Proof. simpl. reflexivity. Qed.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>에서 <code>simpl</code>은</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>mult 3 3
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>을 계산하여 9로 단순화하고 <code>reflexivity</code>는 양변이 동일한 경우 양변을 소거한다. 그러면 더 이상 증명할 대상이 사라지기에 <code>Qed</code>.
우리는 이제 <code>Example</code>이 아니라 <code>Theorem</code>을 증명하도록 하자. <code>Example</code>은 하나의 사례를 다룬다. 그러나 <code>Theorem</code>은 일반적인 대상 모두, 말하자면 forall x such that ~에 해당하는 증명을 다룬다. 이것을 Coq에서는 <code>forall</code>로 쓴다. 나중에는 <code>Fact</code>, <code>Lemma</code>, <code>Remark</code> 등이 더 등장할 것이다.</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Theorem plus_O_n : forall n : nat, 0 + n = n.
Proof.
  intros n. simpl. reflexivity.  Qed.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>사실 <code>reflexivity</code>는 생각보다 많은 역할을 하여, <code>simpl</code>의 역할까지를 함께 수행할 수 있다. 위의 증명은</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Theorem plus_O_n : forall n : nat, 0 + n = n.
Proof.
  intros n. reflexivity.  Qed.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>와 같은 셈. <code>intros</code>는 <code>Theorem</code>에 나타난 양화사를 해당 문맥에 막게 양화하는 역할을 한다. 이러한 증명의 방법들을 tactic이라 부른다. 나중에 더 많은 tactic들을 보게 될 것. 더 많은 증명의 사례를 보자. 아직은 특별한 tactic이 없기에 어려운 것은 없다.
모든 nat type의 n에 1을 더하면 S n이 된다는 증명</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Theorem plus_1_l : forall n:nat, 1 + n = S n.
Proof.
  intros n. reflexivity.  Qed.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>0을 곱하면 0이 된다는 증명. 앞서 말한 것처럼 자동으로 0과 O를 동일시한다.</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Theorem mult_0_l : forall n:nat, 0 * n = 0.
Proof.
  intros n. reflexivity.  Qed.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="rewrite를-써서-전제를-도입하는-증명"><a href="#rewrite를-써서-전제를-도입하는-증명" aria-hidden="true" class="header-anchor">#</a> rewrite를 써서 전제를 도입하는 증명</h3> <p>이제 보다 복잡한 증명을 보자. 전건 -&gt; 후건의 논리 구조를 따르는 증명이다.</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Theorem plus_id_example : forall n m:nat,
  n = m -&gt;
  n + n = m + m.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>n=m인 경우 n+n = m+m이다. 이 경우 전건이 만족되는 n,m에 대하여 후건이 만족된다. 우리는 이를 증명하기 위해 전제(가설)를 도입하고, 이 전제에 맞는 방식으로 식을 다시 <code>rewrite</code>할 것이다.</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Proof.
  (* move both quantifiers into the context: *)
  intros n m.
  (* move the hypothesis into the context: *)
  intros H.
  (* rewrite the goal using the hypothesis: *)
  rewrite -&gt; H.
  reflexivity.  Qed.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>첫 줄의 <code>intros n m</code>으로 증명의 과정에 nat 타입의 n, m을 추가한다. 그리고 두 번째 줄의 <code>intros H</code>로, <code>n=m</code>이라는 전제 H를 추가한다. 그리고 <code>rewrite -&gt; H</code>를 통해 H에 따라 n들을 m으로 고쳐 쓴다. 그럼 양변이 <code>m+m</code>으로 동일해지므로, <code>reflexivity</code>를 적용하여 증명을 마칠 수 있다.
그 다음 예시에는 이보다 조금 더 복잡한 형태로, 여러 번의 <code>implies</code>가 등장한다.</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Theorem plus_id_exercise : forall n m o : nat,
  n = m -&gt; m = o -&gt; n + m = m + o.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>CoqIde의 우상단 창에서, 증명 중에 어떤 전제가 도입되었는지, 어떤 변수들이 양화되었는지를 알 수 있다. n, m, o, 그리고 여러 개의 전제를 intros하면 해결할 수 있다.</p> <h3 id="destruct를-써서-case를-나누는-증명"><a href="#destruct를-써서-case를-나누는-증명" aria-hidden="true" class="header-anchor">#</a> destruct를 써서 case를 나누는 증명</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>Theorem plus_1_neq_0_firsttry : forall n : nat,
  beq_nat (n + 1) 0 = false.
Proof.
  intros n.
  simpl.  (* does nothing! *)
Abort.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>이 경우 beq_nat가 evaluate되지 않는다. 왜냐하면, beq_nat은 인자로 받는 두 수의 case에 따라 그 반환값이 결정되는데, 이 경우 beq_nat의 인자가 n+1이고 n은 어떤 수인지 알려지지 않았다. 따라서 n의 가능한 두 경우, <code>O</code>와 <code>S n</code>에 대해 경우를 나누어 증명을 해야 한다. 여기에서 <code>destruct</code>를 사용한다.</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Theorem plus_1_neq_0 : forall n : nat,
  beq_nat (n + 1) 0 = false.
Proof.
  intros n. destruct n as [| n'].
  - reflexivity.
  - reflexivity.   Qed.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>두 번의 reflexivity는 각각의 case를 증명한다. <code>[| n']</code>는 각각의 case에 변수 이름을 지정한다. 인자를 필요로 하는 type의 경우, 그 인자로 입력될 변수명을 지정해주는 것이다. <code>bullet</code>이라 하는 <code>-</code>기호는 각각의 destruct된 경우, 정확히는 증명에 등장하는 subgoal에 대해 증명을 적용한다. 물론 argument를 받지 않는 inductive type에 대해서도 비슷한 tactic이 가능하다. 예컨대 boolean에 대해서는 true와 false의 case를 나누어 같은 식으로 증명이 진행된다.</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Theorem negb_involutive : forall b : bool,
  negb (negb b) = b.
Proof.
  intros b. destruct b.
  - reflexivity.
  - reflexivity.  Qed.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>앞에서 다른 tactic이 그랬듯이, destruct도 여러 단계 적용될 수 있다. 그리고 bullet 대신 <code>{ ... }</code>의 괄호를 사용할 수도 있다. 괄호는 한 증명의 시작과 끝을 표시한다.</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Theorem andb_commutative' : forall b c, andb b c = andb c b.
Proof.
  intros b c. destruct b.
  { destruct c.
    { reflexivity. }
    { reflexivity. } }
  { destruct c.
    { reflexivity. }
    { reflexivity. } }
Qed.

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>그리고 더 많은 단계에 쓰인다면</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Theorem andb3_exchange :
  forall b c d, andb (andb b c) d = andb (andb b d) c.
Proof.
  intros b c d. destruct b.
  - destruct c.
    { destruct d.
      - reflexivity.
      - reflexivity. }
    { destruct d.
      - reflexivity.
      - reflexivity. }
  - destruct c.
    { destruct d.
      - reflexivity.
      - reflexivity. }
    { destruct d.
      - reflexivity.
      - reflexivity. }
Qed.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div></div> <!----> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated: </span> <span class="time">7/10/2019, 2:38:07 AM</span></div></footer> <!----> </main> <div class="valine-wrapper" data-v-ef239608><div id="valine" data-v-ef239608></div></div></div> <div class="back-to-ceiling" style="right:1rem;bottom:3rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;background-color:rgba(231, 234, 241,.5);display:none;" data-v-2c9945c0 data-v-2c9945c0><i class="iconfont component-up" data-v-2c9945c0></i></div></div></div></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.4f221293.js" defer></script><script src="/blog/assets/js/5.caf4d2c7.js" defer></script><script src="/blog/assets/js/2.7734f288.js" defer></script><script src="/blog/assets/js/1.d3487e4a.js" defer></script><script src="/blog/assets/js/18.5b122441.js" defer></script>
  </body>
</html>
