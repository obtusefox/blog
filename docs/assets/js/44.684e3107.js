(window.webpackJsonp=window.webpackJsonp||[]).push([[44],{239:function(t,a,s){"use strict";s.r(a);var e=s(0),n=Object(e.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("div",{staticClass:"content"},[s("h1",{attrs:{id:"hoare-logic-part-i"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hoare-logic-part-i","aria-hidden":"true"}},[t._v("#")]),t._v(" Hoare Logic, Part I")]),t._v(" "),s("p",[t._v("In the previous chapters, we've defined "),s("code",[t._v("Imp")]),t._v(" language, which is pretty simple, yet captures the key features of languages like C, Java, and so on. Additionally, we've proved some basic properties like:")]),t._v(" "),s("div",{staticClass:"language-ocaml extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ocaml"}},[s("code",[t._v("    "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" determinism "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("of")]),t._v(" evaluation\n\n    "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" equivalence "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("of")]),t._v(" some different ways "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("of")]),t._v(" writing down the\n      definitions "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("e"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("g"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" functional "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("and")]),t._v(" relational definitions "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("of")]),t._v("\n      arithmetic expression evaluation"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" guaranteed termination "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("of")]),t._v(" certain classes "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("of")]),t._v(" programs\n\n    "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" correctness "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v(" the sense "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("of")]),t._v(" preserving meaning"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("of")]),t._v(" a number\n      "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("of")]),t._v(" useful program transformations\n\n    "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" behavioral equivalence "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("of")]),t._v(" programs "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v(" the "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("Equiv"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n      chapter"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("We will develop the topic in this, and later chapters. Especially in this chapter, we will work on a reasoning system named "),s("strong",[t._v("Hoare Logic")]),t._v(". Hoare Logic consists of how to write down the specification of a program, and how to prove their correctness.")]),t._v(" "),s("h2",{attrs:{id:"denoting-assertions"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#denoting-assertions","aria-hidden":"true"}},[t._v("#")]),t._v(" Denoting Assertions")]),t._v(" "),s("p",[t._v("First, we need a way of making assertions about properties.")]),t._v(" "),s("div",{staticClass:"language-ocaml extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ocaml"}},[s("code",[t._v("Definition Assertion "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":=")]),t._v(" state "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v(" Prop"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n")])])]),s("p",[t._v("So, an assertion takes a state, and outputs corresponding Prop about the state.")]),t._v(" "),s("div",{staticClass:"language-ocaml extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ocaml"}},[s("code",[t._v("Check Assertion"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n")])])]),s("p",[t._v("Above command will output "),s("code",[t._v("Type")]),t._v(", as an assertion is actually a type.")]),t._v(" "),s("div",{staticClass:"language-ocaml extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ocaml"}},[s("code",[t._v("Definition as1 "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Assertion "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fun")]),t._v(" st "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" st X "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3.")]),t._v("\n")])])]),s("p",[s("code",[t._v("as1")]),t._v(" is an assertion, which means that for any state "),s("code",[t._v("st")]),t._v(", "),s("code",[t._v("X = 3")]),t._v(" holds.")]),t._v(" "),s("div",{staticClass:"language-ocaml extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ocaml"}},[s("code",[t._v("Check as1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n")])])]),s("p",[t._v("Above will show that "),s("code",[t._v("as1")]),t._v(" is an "),s("code",[t._v("Assertion")]),t._v(".")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("Check fun (st:state) => st X = 3.\n")])])]),s("p",[t._v("will show that "),s("code",[t._v("as1")]),t._v(" is a function which takes a state and returns a Prop.")]),t._v(" "),s("p",[t._v('So, "Formally, an assertion is just a family of propositions indexed by a [state]." However, the way of writing an assertion like above way is pretty cumbersome. As we are talking about a state in a Prop, we can ommit '),s("code",[t._v("st")]),t._v("s.")]),t._v(" "),s("div",{staticClass:"language-ocaml extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ocaml"}},[s("code",[t._v("  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fun")]),t._v(" st "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("st Z"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("st Z"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<=")]),t._v(" m "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("\\\n      "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("~")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("S "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("st Z"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("S "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("st Z"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<=")]),t._v(" m"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("will be written as:")]),t._v(" "),s("div",{staticClass:"language-ocaml extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ocaml"}},[s("code",[t._v("Z "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" Z "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<=")]),t._v(" m "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("\\ "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("~")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("S Z"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("S Z"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<=")]),t._v(" m"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n")])])]),s("h3",{attrs:{id:"some-conventions-in-the-chapter"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#some-conventions-in-the-chapter","aria-hidden":"true"}},[t._v("#")]),t._v(" Some Conventions in the Chapter")]),t._v(" "),s("p",[t._v("In the chapter, certain naming conventions will be used to name many things. For variables, uppercase letters like X, Y, Z will denote Imp variables, while lovercase letters like x, y, m, n will denote ordinary Coq variables.")]),t._v(" "),s("h3",{attrs:{id:"assertions-on-implication"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#assertions-on-implication","aria-hidden":"true"}},[t._v("#")]),t._v(" Assertions on Implication")]),t._v(" "),s("div",{staticClass:"language-ocaml extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ocaml"}},[s("code",[t._v("Definition assert"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("_")]),t._v("implies "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("P Q "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Assertion"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Prop "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":=")]),t._v("\n  forall st"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" P st "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v(" Q st"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n\nNotation "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"P ->> Q"')]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("assert"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("_")]),t._v("implies P Q"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n                      "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("at level "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("80")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" hoare"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("_")]),t._v("spec"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("_")]),t._v("scope"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n")])])]),s("p",[t._v("Also, "),s("code",[t._v("P ->> Q")]),t._v(" means that P implies Q, i.e. if P holds in some state st, Q will also holds in st. "),s("code",[t._v("hoare_spec_scope")]),t._v(" means that the notation will only be used in certain scopes, that is, in this case, "),s("code",[t._v("hoare_spec_scope")]),t._v(".")]),t._v(" "),s("div",{staticClass:"language-ocaml extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ocaml"}},[s("code",[t._v("Open Scope hoare"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("_")]),t._v("spec"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("_")]),t._v("scope"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n")])])]),s("p",[t._v("we can open the scope like this, and,")]),t._v(" "),s("div",{staticClass:"language-ocaml extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ocaml"}},[s("code",[t._v("Notation "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"P <<->> Q"')]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":=")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("P "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->>")]),t._v(" Q "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("\\ Q "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->>")]),t._v(" P"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("at level "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("80")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" hoare"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("_")]),t._v("spec"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("_")]),t._v("scope"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n")])])]),s("p",[t._v("will define iff notation.")]),t._v(" "),s("h2",{attrs:{id:"hoare-triple"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hoare-triple","aria-hidden":"true"}},[t._v("#")]),t._v(" Hoare Triple")]),t._v(" "),s("p",[t._v("The behaviour of a command can be thought to be transitioning from one state to another. So, let's say, a command "),s("code",[t._v("c")]),t._v(" starts in a "),s("code",[t._v("st")]),t._v(" state and terminates in a final state "),s("code",[t._v("st'")]),t._v(". In this manner, "),s("code",[t._v("P->>Q")]),t._v(" means that if "),s("code",[t._v("st")]),t._v(" satisfy P, then "),s("code",[t._v("st'")]),t._v(" will satisfy Q. This is called a "),s("strong",[t._v("Hoare Triple")]),t._v(". "),s("code",[t._v("P")]),t._v(" and "),s("code",[t._v("Q")]),t._v(" is called the precondition and postcondition of "),s("code",[t._v("c")]),t._v(", respectively.")]),t._v(" "),s("div",{staticClass:"language-ocaml extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ocaml"}},[s("code",[t._v("Definition hoare"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("_")]),t._v("triple\n           "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("P "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Assertion"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("c "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" com"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("Q "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Assertion"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Prop "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":=")]),t._v("\n  forall st st'"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n     st "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v(" c "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" st'  "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("\n     P st  "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("\n     Q st'"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n")])])]),s("p",[t._v("When written formally, it can be interpreted like this: if "),s("code",[t._v("st")]),t._v(", with a command "),s("code",[t._v("c")]),t._v(", progress to "),s("code",[t._v("st'")]),t._v(", if "),s("code",[t._v("P")]),t._v(" holds for "),s("code",[t._v("st")]),t._v(", "),s("code",[t._v("Q")]),t._v(" holds for "),s("code",[t._v("st'")]),t._v(".")]),t._v(" "),s("div",{staticClass:"language-ocaml extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ocaml"}},[s("code",[t._v("Notation "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"{{ P }}  c  {{ Q }}"')]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":=")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("hoare"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("_")]),t._v("triple P c Q"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("at level "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("90")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" c at next level"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" hoare"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("_")]),t._v("spec"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("_")]),t._v("scope"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n")])])]),s("p",[t._v("We will use more compact notation above.")]),t._v(" "),s("p",[t._v("[Continued]")])])}],!1,null,null,null);a.default=n.exports}}]);