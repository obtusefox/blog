(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{183:function(a,t,n){"use strict";n.r(t);var e=n(0),s=Object(e.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var a=this,t=a.$createElement,n=a._self._c||t;return n("div",{staticClass:"content"},[n("h2",{attrs:{id:"numbers-module"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#numbers-module","aria-hidden":"true"}},[a._v("#")]),a._v(" Numbers Module")]),a._v(" "),n("p",[a._v("Coq에서는, 다른 언어와 마찬가지로, 모듈 시스템을 제공한다. 우리는 자연수 타입 선언과 그와 관련된 함수들을 Module로 만들어보도록 하자. "),n("code",[a._v("Module X")]),a._v("로 시작하여, 중간에 해당 모듈에 들어갈 타입 정의를 적고, "),n("code",[a._v("End X")]),a._v("로 끝내준다.")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("Module NatPlayground.\n... [ 여기에 코드를 입력 ]\nEnd NatPlayground.\n")])])]),n("h3",{attrs:{id:"numbers-type-정의"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#numbers-type-정의","aria-hidden":"true"}},[a._v("#")]),a._v(" Numbers type 정의")]),a._v(" "),n("p",[a._v("이제 그 내부를 채워보자. 마치 Nil과 Cons로 리스트 타입을 정의하던 것처럼,")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("Inductive nat : Type :=\n  | O : nat\n  | S : nat -> nat.\n")])])]),n("p",[a._v("O로, Nil처럼 0을 정의하고, S로, Cons처럼 그에 1씩 더해짐을 표현해보자. "),n("code",[a._v("S(O)")]),a._v("는 1, "),n("code",[a._v("S(S(O))")]),a._v("는 2... 그럼 우리는 숫자를 표현하는 방법, representation까지를 만든 셈이다.\n이것은 단순히 표기의 문제일 뿐이니,")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("Inductive nat' : Type :=\n  | stop : nat'\n  | tick : nat' -> nat'.\n")])])]),n("p",[a._v("와 같이 적어도 무방하다. 이름만 다르지 같은 데이터 구조를 나타내기 때문.")]),a._v(" "),n("h3",{attrs:{id:"numbers-함수"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#numbers-함수","aria-hidden":"true"}},[a._v("#")]),a._v(" Numbers 함수")]),a._v(" "),n("p",[a._v("그럼 함수를 만들어보자. nat type의 n에 대해, 그 predecessor를 반환하는 pred함수.")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("Definition pred (n : nat) : nat :=\n  match n with\n    | O => O\n    | S n' => n'\n  end.\n")])])]),n("p",[a._v("일단 O에 대해서는 predecessor가 O라고 정하자. 그럼 O에 대해서는 O를 반환하고, 그보다 큰 어떠한 S(n')에 대해서는 n'을 반환한다. 이렇게 numbers 타입들을 정의해보았다.\n그런데 coq는 자동으로 데이터 타입을 내부적으로 숫자로 변환하기도 한다.")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("Check (S (S (S (S O)))).\n")])])]),n("p",[a._v("을 확인하면")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("  4 : nat\n")])])]),n("p",[a._v("값이 반환된다. 자동으로 constructor들을 정의해준 것을 알 수 있다.\n이제 이 숫자값에 대해, pred와 유사하게 minustwo 함수를 정의해보자. 우리는 음수 타입을 정의하지 않았으므로, 음수값에 대해서는 O를 반환하자.")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("Definition minustwo (n : nat) : nat :=\n  match n with\n    | O => O\n    | S O => O\n    | S (S n') => n'\n  end.\n")])])]),n("p",[a._v("으로 정의하고")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("Compute (minustwo 4).\n")])])]),n("p",[a._v("계산해보면, "),n("code",[a._v("2: nat")]),a._v(" 값을 반환한다. 증명 과정에선 compute 대신 simpl.을 사용하여 evaluate할 수 있다.")]),a._v(" "),n("h3",{attrs:{id:"fixpoint"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#fixpoint","aria-hidden":"true"}},[a._v("#")]),a._v(" Fixpoint")]),a._v(" "),n("p",[a._v("앞서 정의한 함수들은 사실 간단한 경우들이다. 그런데 실제로 무언가 유용하거나 좀 더 복잡한 함수를 만들기 위해서는 단순히 각 타입에 대해 한 번에 evaluation이 끝나는 것이 아니라, recursion이 필요한 경우가 있다. 이런 타입에 대해서는 Fixpoint로 함수 선언을 한다.\n인자로 주어진 값이 짝수인지를 판별하는 함수를 선언해보자.")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("Fixpoint evenb (n:nat) : bool :=\n  match n with\n  | O        => true\n  | S O      => false\n  | S (S n') => evenb n'\n  end.\n")])])]),n("p",[a._v("0, 1의 경우에는 앞서 정의한 바와 같이 정의가 되지만 그보다 큰 수에 대해서는 재귀적으로 함수 정의를 하게 된다. "),n("code",[a._v("S (S n')")]),a._v("의 경우, 다시 적자면 "),n("code",[a._v("1 + 1 + n'")]),a._v("의 경우는 "),n("code",[a._v("n'")]),a._v("이 짝수인지를 evaluate하여 반환한다.\n비슷한 방식으로 두 자연수를 더하는 plus 함수를 정의해보자.")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("Fixpoint plus (n : nat) (m : nat) : nat :=\n  match n with\n    | O => m\n    | S n' => S (plus n' m)\n  end.\n")])])]),n("p",[a._v("이를 바탕으로 mult 함수까지 정의해보자. 여러 인자가 같은 타입인 경우 한 번에 타입 선언을 할 수 있다.")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("Fixpoint mult (n m : nat) : nat :=\n  match n with\n    | O => O\n    | S n' => plus m (mult n' m)\n  end.\n")])])]),n("p",[a._v("혹은, 여러 인자를 한 번에 "),n("code",[a._v(",")]),a._v("로 구분하여 case matching을 할 수 있다. 대해, 다른 인자의 값이 상관 없는 경우 case matching에서 상관 없는 인자를 "),n("code",[a._v("_")]),a._v("로 적을 수 있다.")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("Fixpoint minus (n m:nat) : nat :=\n  match n, m with\n  | O   , _    => O\n  | S _ , O    => n\n  | S n', S m' => minus n' m'\n  end.\n")])])]),n("p",[a._v("이 또한 함수형 프로그램에서 익숙한 convention이다. 이상으로 number type에 대한 간략한 예제를 마친다. 추가적인 exercise는 boolean 예제보단 조금씩 머리를 쓰긴 해야 하지만, 마찬가지로 그렇게 어렵진 않다.")]),a._v(" "),n("h3",{attrs:{id:"notaion에-관해"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#notaion에-관해","aria-hidden":"true"}},[a._v("#")]),a._v(" Notaion에 관해")]),a._v(" "),n("p",[a._v("위에서 하던 대로 notation을 적용하자. 그런데 위와 달리 at level, associativity 같은 개념이 추가된다.")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v('Notation "x + y" := (plus x y)\n                       (at level 50, left associativity)\n                       : nat_scope.\nNotation "x - y" := (minus x y)\n                       (at level 50, left associativity)\n                       : nat_scope.\nNotation "x * y" := (mult x y)\n                       (at level 40, left associativity)\n                       : nat_scope.\n')])])]),n("p",[a._v('나중에 더 보겠지만, at level은 우선순위를 뜻한다.\nassociativity는 계산이 어느 방향으로 associative한지를 표현한다.\n이에 대해서는 추후 더 자세히 다루도록 한다. "More on Notaion"에서.')])])}],!1,null,null,null);s.options.__file="3-numbers.md";t.default=s.exports}}]);