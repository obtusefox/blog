(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{295:function(t,s,a){"use strict";a.r(s);var n=a(0),e=Object(n.a)({},function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"equivalence-of-programs"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#equivalence-of-programs","aria-hidden":"true"}},[t._v("#")]),t._v(" Equivalence of Programs")]),t._v(" "),a("p",[t._v("Before you move on: If you are not familiar with "),a("code",[t._v("Imp")]),t._v(" in the "),a("strong",[t._v("Logical Foundations")]),t._v(" volume, you might want to review it.")]),t._v(" "),a("p",[t._v("In this beginning chapter of "),a("strong",[t._v("Programming Language Foundations")]),t._v(", we will first deal with equivalences of programs. That is, if two programs, given same states, evaluates to same values, they can be said to be equivalent. W will use the simple language "),a("code",[t._v("Imp")]),t._v(" we defined in the "),a("strong",[t._v("Logical Foundations")]),t._v(" volume.")]),t._v(" "),a("h2",{attrs:{id:"definitions"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#definitions","aria-hidden":"true"}},[t._v("#")]),t._v(" Definitions")]),t._v(" "),a("h3",{attrs:{id:"equivalence"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#equivalence","aria-hidden":"true"}},[t._v("#")]),t._v(" Equivalence")]),t._v(" "),a("div",{staticClass:"language-ocaml line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-ocaml"}},[a("code",[t._v("Definition aequiv "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a1 a2 "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" aexp"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Prop "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":=")]),t._v("\n  forall "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("st "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" state"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    aeval st a1 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" aeval st a2"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n\nDefinition bequiv "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("b1 b2 "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" bexp"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Prop "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":=")]),t._v("\n  forall "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("st "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" state"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    beval st b1 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" beval st b2"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br")])]),a("p",[t._v("Given the same states, if two expressions are evaluated to a same value, they can be said to be equivalent. Let's prove some small facts about equivalence.")]),t._v(" "),a("div",{staticClass:"language-ocaml line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-ocaml"}},[a("code",[t._v("Theorem aequiv"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("_")]),t._v("example"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" aequiv "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("X "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" X"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.")]),t._v("\nProof"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n  intros st"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v(" simpl"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v(" omega"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\nQed"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n\nTheorem bequiv"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("_")]),t._v("example"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" bequiv "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("X "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" X "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),t._v("imp "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\nProof"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n  intros st"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v(" unfold beval"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n  rewrite aequiv"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("_")]),t._v("example"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v(" reflexivity"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\nQed"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br"),a("span",{staticClass:"line-number"},[t._v("9")]),a("br"),a("span",{staticClass:"line-number"},[t._v("10")]),a("br")])]),a("p",[t._v("Now, let's move on to some other trivial theorems.")]),t._v(" "),a("div",{staticClass:"language-ocaml line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-ocaml"}},[a("code",[t._v("Theorem skip"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("_")]),t._v("left "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" forall c"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  cequiv\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("SKIP"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" c"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    c"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\nProof"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("(* WORKED IN CLASS *)")]),t._v("\n  intros c st st'"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n  split"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" intros H"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("(* -> *)")]),t._v("\n    inversion H"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" subst"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n    inversion H2"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v(" subst"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n    assumption"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("(* <- *)")]),t._v("\n    apply E"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("_")]),t._v("Seq "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("with")]),t._v(" st"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n    apply E"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("_")]),t._v("Skip"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n    assumption"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\nQed"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br"),a("span",{staticClass:"line-number"},[t._v("9")]),a("br"),a("span",{staticClass:"line-number"},[t._v("10")]),a("br"),a("span",{staticClass:"line-number"},[t._v("11")]),a("br"),a("span",{staticClass:"line-number"},[t._v("12")]),a("br"),a("span",{staticClass:"line-number"},[t._v("13")]),a("br"),a("span",{staticClass:"line-number"},[t._v("14")]),a("br"),a("span",{staticClass:"line-number"},[t._v("15")]),a("br"),a("span",{staticClass:"line-number"},[t._v("16")]),a("br"),a("span",{staticClass:"line-number"},[t._v("17")]),a("br")])]),a("p",[t._v("Proof for the theorem isn't that complex. One thing you might noticed is that just using "),a("code",[t._v("intros")]),t._v(" will not introduce st and st'. But as soon as you split, st and st' will be automatically introduced. Introducing st and st` explicitly will make it easier to follow our own thesis.")]),t._v(" "),a("p",[t._v("Also, just using "),a("code",[t._v("inversion")]),t._v(" for every case won't work, as they will yields too many subcases and it will only complicate the problem more. You should think before proceed.")]),t._v(" "),a("p",[t._v("[ Not Finished ]")])])},[],!1,null,null,null);s.default=e.exports}}]);