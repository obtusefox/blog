(window.webpackJsonp=window.webpackJsonp||[]).push([[49],{69:function(t,a,s){"use strict";s.r(a);var n=s(1),e=function(t){t.options.__data__block__={po:"popopo"}},o=Object(n.a)({},function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"equivalence-of-programs"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#equivalence-of-programs","aria-hidden":"true"}},[t._v("#")]),t._v(" Equivalence of Programs")]),t._v(" "),s("article-info"),s("p",[t._v("Before you move on: If you are not familiar with "),s("code",[t._v("Imp")]),t._v(" in the "),s("strong",[t._v("Logical Foundations")]),t._v(" volume, you might want to review it.")]),t._v(" "),s("p",[t._v("In this beginning chapter of "),s("strong",[t._v("Programming Language Foundations")]),t._v(", we will first deal with equivalences of programs. That is, if two programs, given same states, evaluates to same values, they can be said to be equivalent. W will use the simple language "),s("code",[t._v("Imp")]),t._v(" we defined in the "),s("strong",[t._v("Logical Foundations")]),t._v(" volume.")]),t._v(" "),s("h2",{attrs:{id:"definitions"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#definitions","aria-hidden":"true"}},[t._v("#")]),t._v(" Definitions")]),t._v(" "),s("h3",{attrs:{id:"equivalence"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#equivalence","aria-hidden":"true"}},[t._v("#")]),t._v(" Equivalence")]),t._v(" "),s("div",{staticClass:"language-ocaml extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ocaml"}},[s("code",[t._v("Definition aequiv "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a1 a2 "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" aexp"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Prop "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":=")]),t._v("\n  forall "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("st "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" state"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    aeval st a1 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" aeval st a2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n\nDefinition bequiv "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("b1 b2 "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" bexp"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Prop "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":=")]),t._v("\n  forall "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("st "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" state"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    beval st b1 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" beval st b2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n")])])]),s("p",[t._v("Given the same states, if two expressions are evaluated to a same value, they can be said to be equivalent. Let's prove some small facts about equivalence.")]),t._v(" "),s("div",{staticClass:"language-ocaml extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ocaml"}},[s("code",[t._v("Theorem aequiv"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("_")]),t._v("example"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" aequiv "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("X "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" X"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.")]),t._v("\nProof"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n  intros st"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v(" simpl"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v(" omega"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\nQed"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n\nTheorem bequiv"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("_")]),t._v("example"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" bequiv "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("X "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" X "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),t._v("imp "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\nProof"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n  intros st"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v(" unfold beval"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n  rewrite aequiv"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("_")]),t._v("example"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v(" reflexivity"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\nQed"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n")])])]),s("p",[t._v("Now, let's move on to some other trivial theorems.")]),t._v(" "),s("div",{staticClass:"language-ocaml extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ocaml"}},[s("code",[t._v("Theorem skip"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("_")]),t._v("left "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" forall c"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  cequiv\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("SKIP"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" c"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    c"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\nProof"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("(* WORKED IN CLASS *)")]),t._v("\n  intros c st st'"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n  split"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" intros H"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("(* -> *)")]),t._v("\n    inversion H"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" subst"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n    inversion H2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v(" subst"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n    assumption"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("(* <- *)")]),t._v("\n    apply E"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("_")]),t._v("Seq "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("with")]),t._v(" st"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n    apply E"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("_")]),t._v("Skip"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n    assumption"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\nQed"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n")])])]),s("p",[t._v("Proof for the theorem isn't that complex. One thing you might noticed is that just using "),s("code",[t._v("intros")]),t._v(" will not introduce st and st'. But as soon as you split, st and st' will be automatically introduced. Introducing st and st` explicitly will make it easier to follow our own thesis.")]),t._v(" "),s("p",[t._v("Also, just using "),s("code",[t._v("inversion")]),t._v(" for every case won't work, as they will yields too many subcases and it will only complicate the problem more. You should think before proceed.")]),t._v(" "),s("p",[t._v("[ Not Finished ]")])],1)},[],!1,null,null,null);"function"==typeof e&&e(o),o.options.__file="1-equiv.md";a.default=o.exports}}]);