(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{279:function(n,s,e){"use strict";e.r(s);var a=e(0),t=Object(a.a)({},function(){var n=this,s=n.$createElement,e=n._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h2",{attrs:{id:"proof-by-induction"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#proof-by-induction","aria-hidden":"true"}},[n._v("#")]),n._v(" Proof by Induction")]),n._v(" "),e("p",[e("code",[n._v("Induction.v")]),n._v(" 파일의 내용을 학습하자.")]),n._v(" "),e("h3",{attrs:{id:"basics를-import하기"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#basics를-import하기","aria-hidden":"true"}},[n._v("#")]),n._v(" Basics를 import하기")]),n._v(" "),e("p",[n._v("다음 장을 시작하기에 앞서 앞장에서 다룬 Basics를 컴파일하여 import할 필요가 있다. 윈도우에서는 coqIde에서의 컴파일이 동작하지 않는다. 고로 유닉스 환경에서, 해당 경로에서 bash 명령어로 "),e("code",[n._v("make")]),n._v("를 실행하거나, 혹은 리눅스에서 실행한 coqIde에서 make를 실행하자.")]),n._v(" "),e("h3",{attrs:{id:"n-n-0의-증명"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#n-n-0의-증명","aria-hidden":"true"}},[n._v("#")]),n._v(" n = n+0의 증명")]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("Theorem plus_n_O_firsttry : forall n:nat,\n  n = n + 0.\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br")])]),e("p",[n._v("을 증명해보자.")]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("Proof.\n  intros n.\n  simpl. (* Does nothing! *)\nAbort.\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br")])]),e("p",[n._v("그런데 simpl 단계에서 아무것도 되지 않는다. n의 case에 따라 "),e("code",[n._v("+")]),n._v("가 simplified될 수 없기 때문에. 그럼 앞에서처럼 destruct를 써서 case를 나눠야 할까?")]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("Theorem plus_n_O_secondtry : forall n:nat,\n  n = n + 0.\nProof.\n  intros n. destruct n as [| n'].\n  - (* n = 0 *)\n    reflexivity. (* so far so good... *)\n  - (* n = S n' *)\n    simpl.       (* ...but here we are stuck again *)\nAbort.\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br"),e("span",{staticClass:"line-number"},[n._v("7")]),e("br"),e("span",{staticClass:"line-number"},[n._v("8")]),e("br"),e("span",{staticClass:"line-number"},[n._v("9")]),e("br")])]),e("p",[n._v("마찬가지로 아무 일도 일어나지 않는다. 왜냐하면 두 번째 case에서 S(n' + 0)이 나타나며 다시금 "),e("code",[n._v("simpl.")]),n._v("이 아무것도 할 수 없기 때문. 여기에서 induction을 도입한다. 귀납. 우리의 예시에선, 어떠한 "),e("code",[n._v("n")]),n._v("에 대하여 "),e("code",[n._v("n = n + 0")]),n._v("이 성립한다면 "),e("code",[n._v("S n")]),n._v("에 대해서도 마찬가지가 성립함을 보여야 한다. 그런데 "),e("code",[n._v("n = n + 0")]),n._v("을 이미 보였다면, "),e("code",[n._v("S (n + 0)")]),n._v("에서 "),e("code",[n._v("n + 0")]),n._v("을 "),e("code",[n._v("n")]),n._v("으로 "),e("code",[n._v("rewrite")]),n._v("할 수 있을 것이다. 코드로는 다음과 같이 쓴다.")]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("Theorem plus_n_O : forall n:nat, n = n + 0.\nProof.\n  intros n. induction n as [| n' IHn'].\n  - (* n = 0 *)    reflexivity.\n  - (* n = S n' *) simpl. rewrite <- IHn'. reflexivity.  Qed.\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br")])]),e("p",[n._v("IHn'은 귀납적 전제에 붙여주는 이름이다. 따라서 IHn'이 아니라 다른 이름이 되어도 괜찮다. "),e("code",[n._v("rewrite <- IHn'")]),n._v("를 통해 "),e("code",[n._v("n+0")]),n._v("을 "),e("code",[n._v("n")]),n._v("으로 대체한다. 그럼 위에서 해결되지 않던 "),e("code",[n._v("S (n' + 0)")]),n._v("의 경우가 해결된다.\n다음 예시로, 모든 n에 대하여 "),e("code",[n._v("minus n n")]),n._v("이 "),e("code",[n._v("0")]),n._v("임을 증명하자. destruct를 쓰는 증명의 경우")]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("Proof.\n  intros n.\n  destruct n as [|n'].\n  - reflexivity.\n  - simpl.\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br")])]),e("p",[n._v("마찬가지로 "),e("code",[n._v("S n'")]),n._v("에서 막힌다. 그렇기에 "),e("code",[n._v("induction")]),n._v("을 도입하자.")]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("Proof.\n  induction n as [| n' IHn'].\n  - (* n = 0 *)\n    simpl. reflexivity.\n  - (* n = S n' *)\n    simpl. rewrite -> IHn'. reflexivity.  Qed.\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br")])]),e("p",[n._v("여기서 "),e("code",[n._v("intros")]),n._v("는 불필요하다. "),e("code",[n._v("induction")]),n._v("이 "),e("code",[n._v("intros")]),n._v("의 역할까지 해주기 때문이다.\n나머지 예제들은 천천히 여태껏 배운 tactic들을 써보면 된다. 다만 "),e("code",[n._v("rewrite")]),n._v("에서 화살표의 방향에 따라 다르게 적용된다는 점에 주의하자. 이제부터는 생각을 하며 증명을 해야 한다. 그리고, 앞에서 증명한 Theorem을 바탕으로, 예를 들어 "),e("code",[n._v("rewrite plus_n_O")]),n._v("과 같은 tactic을 사용해야 한다. "),e("code",[n._v("plus_comm")]),n._v("은 "),e("code",[n._v("plus_n_0")]),n._v("와 "),e("code",[n._v("plus_n_Sm")]),n._v("을 사용하자.")])])},[],!1,null,null,null);s.default=t.exports}}]);