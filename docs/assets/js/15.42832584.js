(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{172:function(e,a,t){"use strict";t.r(a);var n=t(0),s=Object(n.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("div",{staticClass:"content"},[t("h2",{attrs:{id:"enumerated-types"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#enumerated-types","aria-hidden":"true"}},[e._v("#")]),e._v(" Enumerated Types")]),e._v(" "),t("p",[e._v("Coq 자체는 굉장히 기능이 제한적이고, 심지어 bool, int 등의 타입도 제공을 안한다. 대신 타입을 선언하기 좋은 방법을 제공한다고.")]),e._v(" "),t("p",[e._v("우리는 먼저 enumerated type을 살펴볼 것이다. 예를 들어 요일 type의 원소들은 유한하고, 각각은 argument를 받지 않는, 그 자체로 constructor이다. 이런 element들의 유한한 set이 한 type을 이루는 경우, enumerated type에 속한다. 헤아릴 수 있는 형태라고 생각하자.")]),e._v(" "),t("h3",{attrs:{id:"교재"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#교재","aria-hidden":"true"}},[e._v("#")]),e._v(" 교재")]),e._v(" "),t("p",[t("em",[e._v("Software Foundations의 설명을 대부분 따라가되, 적당히 내게 필요한 부분만 간추린다.")])]),e._v(" "),t("h3",{attrs:{id:"요일을-타입으로-나타내기"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#요일을-타입으로-나타내기","aria-hidden":"true"}},[e._v("#")]),e._v(" 요일을 타입으로 나타내기")]),e._v(" "),t("p",[e._v("그럼 그 예시로, 요일을 coq에서 선언해보자.")]),e._v(" "),t("h4",{attrs:{id:"요일-타입의-선언"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#요일-타입의-선언","aria-hidden":"true"}},[e._v("#")]),e._v(" 요일 타입의 선언")]),e._v(" "),t("p",[e._v("일단 day라는 타입을 선언하고")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Inductive day : Type :=\n")])])]),t("p",[e._v("그에 대해 type의 member들을 정의하자.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Inductive day : Type :=\n  | monday : day\n  | tuesday : day\n  | wednesday : day\n  | thursday : day\n  | friday : day\n  | saturday : day\n  | sunday : day.\n")])])]),t("p",[e._v("그리고 이에 대해 function next_weekday를 정의해보자. 우리에게 익숙한 functional programming의 convention대로,")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Definition next_weekday (d:day) : day :=\n")])])]),t("p",[e._v("next_weekday 함수는 day 타입의 d를 인자로 받아서 day 타입을 내놓는다.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Definition next_weekday (d:day) : day :=\n  match d with\n  | monday    => tuesday\n  | tuesday   => wednesday\n  | wednesday => thursday\n  | thursday  => friday\n  | friday    => monday\n  | saturday  => monday\n  | sunday    => monday\n  end.\n")])])]),t("p",[e._v("그리고 d와 matching하여 각 case에 따라 return 값을 지정한다. Coq는 타입을 추정할 수 있지만 우리의 학습에선 타입을 생략하지 않고 밝힌다. 이제 함수의 값을 evaluate해보자.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Compute (next_weekday friday).\n")])])]),t("p",[e._v("IDE의 오른쪽 아래 Messages 란에")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("     = monday\n     : day\n")])])]),t("p",[e._v("라고 그 계산 결과가 출력된다.\n이제 보다 복잡한 계산을 해보자.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Example test_next_weekday:\n  (next_weekday (next_weekday saturday)) = tuesday.\n")])])]),t("p",[t("code",[e._v("test_next_weekday")]),e._v("라는 예제는, "),t("code",[e._v("(next_weekday (next_weekday saturday)) = tuesday")]),e._v("라는 증명의 subgoal을 만든다. 증명의 내용을 지정하고 이에 대해 이름을 붙이는, 두 가지 역할을 하는 것.\n이제 이 Example을 증명해보자.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Proof. simpl. reflexivity.  Qed.\n")])])]),t("p",[e._v("단계별로, "),t("code",[e._v("simpl")]),e._v("단계에서는, 죄변의 "),t("code",[e._v("(next_weekday (next_weekday saturday))")]),e._v("를 simplify하여 "),t("code",[e._v("tuesday")]),e._v("로 evaluate한다. 그리고 "),t("code",[e._v("reflexivity")]),e._v(" 단계에선 동일한 우변과 좌변을 정리한다. 그럼 더 이상의 subgoal이 없으므로 증명 완료.")]),e._v(" "),t("p",[e._v("비슷한 방식으로 boolean도 정의해보자. 굳이 설명할 필요는 없을만큼 간단하다.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Inductive bool : Type :=\n  | true : bool\n  | false : bool.\n\nDefinition negb (b:bool) : bool :=\n  match b with\n  | true => false\n  | false => true\n  end.\n\nDefinition andb (b1:bool) (b2:bool) : bool :=\n  match b1 with\n  | true => b2\n  | false => false\n  end.\n\nDefinition orb (b1:bool) (b2:bool) : bool :=\n  match b1 with\n  | true => true\n  | false => b2\n  end.\n")])])]),t("p",[e._v("증명 또한 위와 동일하다.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Example test_orb1:  (orb true  false) = true.\nProof. simpl. reflexivity.  Qed.\nExample test_orb2:  (orb false false) = false.\nProof. simpl. reflexivity.  Qed.\nExample test_orb3:  (orb false true)  = true.\nProof. simpl. reflexivity.  Qed.\nExample test_orb4:  (orb true  true)  = true.\nProof. simpl. reflexivity.  Qed.\n")])])]),t("p",[t("code",[e._v("Notation")]),e._v("은 다른 방식으로 이미 정의된 operation을 사용할 수 있게 해준다.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('Notation "x && y" := (andb x y).\nNotation "x || y" := (orb x y).\n')])])]),t("p",[e._v("로 Notation을 정의하면,")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Example test_orb5:  false || false || true = true.\nProof. simpl. reflexivity. Qed.\n")])])]),t("p",[e._v("와 같은 활용이 가능하다.\nExercise에서는 nandb와 andb3를 정의하고 증명하도록 한다. nandb의 경우, andb의 반대라는 것을 염두에 두자. 예를 들어 한 쪽이 false이면 결과값은 true이고, 한 쪽이 true라면 결과값은 다른 쪽의 negation일 것이다. andb3의 경우 하나하나 정의하기보다, 앞에서 만든 definition을 불러와서 활용하자.")])])}],!1,null,null,null);s.options.__file="1-enumerated-types.md";a.default=s.exports}}]);