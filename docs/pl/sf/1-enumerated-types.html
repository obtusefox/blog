<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Basics 1. Enumerated Types | ObtuseCave</title>
    <meta name="description" content="Data의 타입 중 Enumerated Types에 대해 알아보자.">
    
    
    <link rel="preload" href="/blog/assets/css/0.styles.9f33b487.css" as="style"><link rel="preload" href="/blog/assets/js/app.48ed8628.js" as="script"><link rel="preload" href="/blog/assets/js/15.a9c24e69.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.524d0a26.js"><link rel="prefetch" href="/blog/assets/js/11.2bc96267.js"><link rel="prefetch" href="/blog/assets/js/12.ff8aae40.js"><link rel="prefetch" href="/blog/assets/js/13.5d737e9e.js"><link rel="prefetch" href="/blog/assets/js/14.fa172cda.js"><link rel="prefetch" href="/blog/assets/js/16.ed395046.js"><link rel="prefetch" href="/blog/assets/js/17.b98122ec.js"><link rel="prefetch" href="/blog/assets/js/18.ec05d6de.js"><link rel="prefetch" href="/blog/assets/js/19.21af4bfb.js"><link rel="prefetch" href="/blog/assets/js/2.06d97229.js"><link rel="prefetch" href="/blog/assets/js/20.985cc1a7.js"><link rel="prefetch" href="/blog/assets/js/21.9a2819b6.js"><link rel="prefetch" href="/blog/assets/js/22.348dcd0d.js"><link rel="prefetch" href="/blog/assets/js/3.98885e4b.js"><link rel="prefetch" href="/blog/assets/js/4.0fe47e39.js"><link rel="prefetch" href="/blog/assets/js/5.57e84558.js"><link rel="prefetch" href="/blog/assets/js/6.6e408204.js"><link rel="prefetch" href="/blog/assets/js/7.2bb0b13b.js"><link rel="prefetch" href="/blog/assets/js/8.0a21718e.js"><link rel="prefetch" href="/blog/assets/js/9.d1a2472a.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.9f33b487.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">ObtuseCave</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><!---->  <ul class="sidebar-links"><li><div class="sidebar-group first collapsable"><p class="sidebar-heading"><span>About</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>Kotlin Koans</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>Rust 속성</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading open"><span>Software Foundations</span> <span class="arrow down"></span></p> <ul class="sidebar-group-items"><li><a href="/blog/pl/sf/0-settings.html" class="sidebar-link">Basics 0. 기초 셋팅</a></li><li><a href="/blog/pl/sf/1-enumerated-types.html" class="active sidebar-link">Basics 1. Enumerated Types</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/pl/sf/1-enumerated-types.html#enumerated-types" class="sidebar-link">Enumerated Types</a></li></ul></li><li><a href="/blog/pl/sf/2-more-types.html" class="sidebar-link">Basics 2. 보다 다양한 type들</a></li><li><a href="/blog/pl/sf/3-numbers.html" class="sidebar-link">Basics 3. Numbers 구현</a></li></ul></div></li></ul> </div> <div class="page"> <div class="content"><h3 id="교재"><a href="#교재" aria-hidden="true" class="header-anchor">#</a> 교재</h3> <p><em>Software Foundations의 설명을 대부분 따라가되, 적당히 내게 필요한 부분만 간추린다.</em></p> <h2 id="enumerated-types"><a href="#enumerated-types" aria-hidden="true" class="header-anchor">#</a> Enumerated Types</h2> <p>Coq 자체는 굉장히 기능이 제한적이고, 심지어 bool, int 등의 타입도 제공을 안한다. 대신 타입을 선언하기 좋은 방법을 제공한다고.</p> <p>우리는 먼저 enumerated type을 살펴볼 것이다. 예를 들어 요일 type의 원소들은 유한하고, 각각은 argument를 받지 않는, 그 자체로 constructor이다. 이런 element들의 유한한 set이 한 type을 이루는 경우, enumerated type에 속한다. 헤아릴 수 있는 형태라고 생각하자.</p> <h3 id="요일을-타입으로-나타내기"><a href="#요일을-타입으로-나타내기" aria-hidden="true" class="header-anchor">#</a> 요일을 타입으로 나타내기</h3> <p>그럼 그 예시로, 요일을 coq에서 선언해보자.</p> <h4 id="요일-타입의-선언"><a href="#요일-타입의-선언" aria-hidden="true" class="header-anchor">#</a> 요일 타입의 선언</h4> <p>일단 day라는 타입을 선언하고</p> <div class="language- extra-class"><pre class="language-text"><code>Inductive day : Type :=
</code></pre></div><p>그에 대해 type의 member들을 정의하자.</p> <div class="language- extra-class"><pre class="language-text"><code>Inductive day : Type :=
  | monday : day
  | tuesday : day
  | wednesday : day
  | thursday : day
  | friday : day
  | saturday : day
  | sunday : day.
</code></pre></div><p>그리고 이에 대해 function next_weekday를 정의해보자. 우리에게 익숙한 functional programming의 convention대로,</p> <div class="language- extra-class"><pre class="language-text"><code>Definition next_weekday (d:day) : day :=
</code></pre></div><p>next_weekday 함수는 day 타입의 d를 인자로 받아서 day 타입을 내놓는다.</p> <div class="language- extra-class"><pre class="language-text"><code>Definition next_weekday (d:day) : day :=
  match d with
  | monday    =&gt; tuesday
  | tuesday   =&gt; wednesday
  | wednesday =&gt; thursday
  | thursday  =&gt; friday
  | friday    =&gt; monday
  | saturday  =&gt; monday
  | sunday    =&gt; monday
  end.
</code></pre></div><p>그리고 d와 matching하여 각 case에 따라 return 값을 지정한다. Coq는 타입을 추정할 수 있지만 우리의 학습에선 타입을 생략하지 않고 밝힌다. 이제 함수의 값을 evaluate해보자.</p> <div class="language- extra-class"><pre class="language-text"><code>Compute (next_weekday friday).
</code></pre></div><p>IDE의 오른쪽 아래 Messages 란에</p> <div class="language- extra-class"><pre class="language-text"><code>     = monday
     : day
</code></pre></div><p>라고 그 계산 결과가 출력된다.
이제 보다 복잡한 계산을 해보자.</p> <div class="language- extra-class"><pre class="language-text"><code>Example test_next_weekday:
  (next_weekday (next_weekday saturday)) = tuesday.
</code></pre></div><p><code>test_next_weekday</code>라는 예제는, <code>(next_weekday (next_weekday saturday)) = tuesday</code>라는 증명의 subgoal을 만든다. 증명의 내용을 지정하고 이에 대해 이름을 붙이는, 두 가지 역할을 하는 것.
이제 이 Example을 증명해보자.</p> <div class="language- extra-class"><pre class="language-text"><code>Proof. simpl. reflexivity.  Qed.
</code></pre></div><p>단계별로, <code>simpl</code>단계에서는, 죄변의 <code>(next_weekday (next_weekday saturday))</code>를 simplify하여 <code>tuesday</code>로 evaluate한다. 그리고 <code>reflexivity</code> 단계에선 동일한 우변과 좌변을 정리한다. 그럼 더 이상의 subgoal이 없으므로 증명 완료.</p> <p>비슷한 방식으로 boolean도 정의해보자. 굳이 설명할 필요는 없을만큼 간단하다.</p> <div class="language- extra-class"><pre class="language-text"><code>Inductive bool : Type :=
  | true : bool
  | false : bool.

Definition negb (b:bool) : bool :=
  match b with
  | true =&gt; false
  | false =&gt; true
  end.

Definition andb (b1:bool) (b2:bool) : bool :=
  match b1 with
  | true =&gt; b2
  | false =&gt; false
  end.

Definition orb (b1:bool) (b2:bool) : bool :=
  match b1 with
  | true =&gt; true
  | false =&gt; b2
  end.
</code></pre></div><p>증명 또한 위와 동일하다.</p> <div class="language- extra-class"><pre class="language-text"><code>Example test_orb1:  (orb true  false) = true.
Proof. simpl. reflexivity.  Qed.
Example test_orb2:  (orb false false) = false.
Proof. simpl. reflexivity.  Qed.
Example test_orb3:  (orb false true)  = true.
Proof. simpl. reflexivity.  Qed.
Example test_orb4:  (orb true  true)  = true.
Proof. simpl. reflexivity.  Qed.
</code></pre></div><p><code>Notation</code>은 다른 방식으로 이미 정의된 operation을 사용할 수 있게 해준다.</p> <div class="language- extra-class"><pre class="language-text"><code>Notation &quot;x &amp;&amp; y&quot; := (andb x y).
Notation &quot;x || y&quot; := (orb x y).
</code></pre></div><p>로 Notation을 정의하면,</p> <div class="language- extra-class"><pre class="language-text"><code>Example test_orb5:  false || false || true = true.
Proof. simpl. reflexivity. Qed.
</code></pre></div><p>와 같은 활용이 가능하다.
Exercise에서는 nandb와 andb3를 정의하고 증명하도록 한다. nandb의 경우, andb의 반대라는 것을 염두에 두자. 예를 들어 한 쪽이 false이면 결과값은 true이고, 한 쪽이 true라면 결과값은 다른 쪽의 negation일 것이다. andb3의 경우 하나하나 정의하기보다, 앞에서 만든 definition을 불러와서 활용하자.</p></div> <div class="page-edit"><!----> <!----></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/blog/pl/sf/0-settings.html" class="prev">
          Basics 0. 기초 셋팅
        </a></span> <span class="next"><a href="/blog/pl/sf/2-more-types.html">
          Basics 2. 보다 다양한 type들
        </a>
        →
      </span></p></div> </div> <!----></div></div>
    <script src="/blog/assets/js/app.48ed8628.js" defer></script><script src="/blog/assets/js/15.a9c24e69.js" defer></script>
  </body>
</html>
