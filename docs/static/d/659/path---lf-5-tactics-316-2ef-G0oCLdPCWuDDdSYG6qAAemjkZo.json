{"data":{"site":{"siteMetadata":{"title":"Bee starter","author":"[Your Name]","siteUrl":"https://han-minhee.github.io/blog","comment":{"disqusShortName":"","utterances":"han-minhee/blog"},"sponsor":{"buyMeACoffeeId":"jbee"}}},"markdownRemark":{"id":"1c6d3620-e59d-552b-8176-ac337a2a58b3","excerpt":"Tactics: 추가적인 증명의 기술들 apply 다음과 같은 코드가 있다. 그리고 이제 우리는 를 통해 증명을 마칠 수도 있다. 하지만, 그 대신 를 적용하여 rewrite와 reflexivity를 대신할 수 있다. `apply는 조건문과도 함께 쓰일 수 있다. 적용되는 주장이 한 전제의 귀결인 경우, 전제는 증명될 subgoal들에 포함될 것이다. 또한 가설 H…","html":"<h1 id=\"tactics-추가적인-증명의-기술들\"><a href=\"#tactics-%EC%B6%94%EA%B0%80%EC%A0%81%EC%9D%B8-%EC%A6%9D%EB%AA%85%EC%9D%98-%EA%B8%B0%EC%88%A0%EB%93%A4\" aria-label=\"tactics 추가적인 증명의 기술들 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Tactics: 추가적인 증명의 기술들</h1>\n<h2 id=\"apply\"><a href=\"#apply\" aria-label=\"apply permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>apply</h2>\n<p>다음과 같은 코드가 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ocaml\"><pre class=\"language-ocaml\"><code class=\"language-ocaml\">Theorem silly1 <span class=\"token punctuation\">:</span> forall <span class=\"token punctuation\">(</span>n m o p <span class=\"token punctuation\">:</span> nat<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n     n <span class=\"token operator\">=</span> m  <span class=\"token operator\">-></span>\n     <span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">;</span>o<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">;</span>p<span class=\"token punctuation\">]</span> <span class=\"token operator\">-></span>\n     <span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">;</span>o<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>m<span class=\"token punctuation\">;</span>p<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>\nProof<span class=\"token punctuation\">.</span>\n  intros n m o p eq1 eq2<span class=\"token punctuation\">.</span>\n  rewrite <span class=\"token operator\">&lt;-</span> eq1<span class=\"token punctuation\">.</span></code></pre></div>\n<p>그리고 이제 우리는</p>\n<div class=\"gatsby-highlight\" data-language=\"ocaml\"><pre class=\"language-ocaml\"><code class=\"language-ocaml\">rewrite <span class=\"token operator\">-></span> eq2<span class=\"token punctuation\">.</span>\nreflexivity<span class=\"token punctuation\">.</span></code></pre></div>\n<p>를 통해 증명을 마칠 수도 있다. 하지만, 그 대신</p>\n<div class=\"gatsby-highlight\" data-language=\"ocaml\"><pre class=\"language-ocaml\"><code class=\"language-ocaml\">apply eq2</code></pre></div>\n<p>를 적용하여 rewrite와 reflexivity를 대신할 수 있다. `apply는 조건문과도 함께 쓰일 수 있다. 적용되는 주장이 한 전제의 귀결인 경우, 전제는 증명될 subgoal들에 포함될 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ocaml\"><pre class=\"language-ocaml\"><code class=\"language-ocaml\">Theorem silly2 <span class=\"token punctuation\">:</span> forall <span class=\"token punctuation\">(</span>n m o p <span class=\"token punctuation\">:</span> nat<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n     n <span class=\"token operator\">=</span> m  <span class=\"token operator\">-></span>\n     <span class=\"token punctuation\">(</span>forall <span class=\"token punctuation\">(</span>q r <span class=\"token punctuation\">:</span> nat<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> q <span class=\"token operator\">=</span> r <span class=\"token operator\">-></span> <span class=\"token punctuation\">[</span>q<span class=\"token punctuation\">;</span>o<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>r<span class=\"token punctuation\">;</span>p<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span>\n     <span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">;</span>o<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>m<span class=\"token punctuation\">;</span>p<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>\nProof<span class=\"token punctuation\">.</span>\n  intros n m o p eq1 eq2<span class=\"token punctuation\">.</span>\n  apply eq2<span class=\"token punctuation\">.</span> apply eq1<span class=\"token punctuation\">.</span>  Qed<span class=\"token punctuation\">.</span></code></pre></div>\n<p>또한 가설 H를 <code class=\"language-text\">apply</code>한다면 <code class=\"language-text\">forall</code>에 따라 어떤 변수를 양화한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ocaml\"><pre class=\"language-ocaml\"><code class=\"language-ocaml\">Theorem silly3<span class=\"token punctuation\">_</span>firsttry <span class=\"token punctuation\">:</span> forall <span class=\"token punctuation\">(</span>n <span class=\"token punctuation\">:</span> nat<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n     <span class=\"token boolean\">true</span> <span class=\"token operator\">=</span> beq<span class=\"token punctuation\">_</span>nat n <span class=\"token number\">5</span>  <span class=\"token operator\">-></span>\n     beq<span class=\"token punctuation\">_</span>nat <span class=\"token punctuation\">(</span>S <span class=\"token punctuation\">(</span>S n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token number\">7</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">.</span>\nProof<span class=\"token punctuation\">.</span>\n  intros n H<span class=\"token punctuation\">.</span>\n<span class=\"token comment\">(** Here we cannot use [apply] directly, but we can use the [symmetry] tactic, which switches the left and right sides of an equality in the goal. *)</span>\n  symmetry<span class=\"token punctuation\">.</span>\n  simpl<span class=\"token punctuation\">.</span> <span class=\"token comment\">(** (This [simpl] is optional, since [apply] will perform simplification first, if needed.) *)</span>\n  apply H<span class=\"token punctuation\">.</span>  Qed<span class=\"token punctuation\">.</span></code></pre></div>\n<p>바로 <code class=\"language-text\">apply</code>를 쓸 수 없는 경우, <code class=\"language-text\">symmetry</code>를 이용해 양변을 바꿀 수 있다. 혹은, <code class=\"language-text\">apply with</code>로, 적용하는 Theorem이나 Lemma의 특정 변수를 우리가 원하는 값이나 변수로 대체할 수 있다. </p>\n<div class=\"gatsby-highlight\" data-language=\"ocaml\"><pre class=\"language-ocaml\"><code class=\"language-ocaml\">Theorem trans<span class=\"token punctuation\">_</span>eq <span class=\"token punctuation\">:</span> forall <span class=\"token punctuation\">(</span>X<span class=\"token punctuation\">:</span>Type<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>n m o <span class=\"token punctuation\">:</span> X<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  n <span class=\"token operator\">=</span> m <span class=\"token operator\">-></span> m <span class=\"token operator\">=</span> o <span class=\"token operator\">-></span> n <span class=\"token operator\">=</span> o<span class=\"token punctuation\">.</span>\nProof<span class=\"token punctuation\">.</span>\n  intros X n m o eq1 eq2<span class=\"token punctuation\">.</span> rewrite <span class=\"token operator\">-></span> eq1<span class=\"token punctuation\">.</span> rewrite <span class=\"token operator\">-></span> eq2<span class=\"token punctuation\">.</span>\n  reflexivity<span class=\"token punctuation\">.</span>  Qed<span class=\"token punctuation\">.</span></code></pre></div>\n<p>예를 들어 trans_eq는 transitivity를 증명한다. 이 정리를 적용하여 한 사례를 증명해보도록 하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"ocaml\"><pre class=\"language-ocaml\"><code class=\"language-ocaml\">Example trans<span class=\"token punctuation\">_</span>eq<span class=\"token punctuation\">_</span>example' <span class=\"token punctuation\">:</span> forall <span class=\"token punctuation\">(</span>a b c d e f <span class=\"token punctuation\">:</span> nat<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n     <span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">;</span>b<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>c<span class=\"token punctuation\">;</span>d<span class=\"token punctuation\">]</span> <span class=\"token operator\">-></span>\n     <span class=\"token punctuation\">[</span>c<span class=\"token punctuation\">;</span>d<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>e<span class=\"token punctuation\">;</span>f<span class=\"token punctuation\">]</span> <span class=\"token operator\">-></span>\n     <span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">;</span>b<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>e<span class=\"token punctuation\">;</span>f<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>\nProof<span class=\"token punctuation\">.</span>\n  intros a b c d e f eq1 eq2<span class=\"token punctuation\">.</span>\n  apply trans<span class=\"token punctuation\">_</span>eq <span class=\"token keyword\">with</span> <span class=\"token punctuation\">(</span>m<span class=\"token operator\">:=</span><span class=\"token punctuation\">[</span>c<span class=\"token punctuation\">;</span>d<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>\n  apply eq1<span class=\"token punctuation\">.</span> apply eq2<span class=\"token punctuation\">.</span>   Qed<span class=\"token punctuation\">.</span></code></pre></div>\n<p>이 경우, <code class=\"language-text\">apply</code>가 자동으로, <code class=\"language-text\">trans_eq</code>의 <code class=\"language-text\">type X</code>를 <code class=\"language-text\">nat</code>으로, <code class=\"language-text\">n</code>을 <code class=\"language-text\">[a;b]</code>로, <code class=\"language-text\">o</code>를 <code class=\"language-text\">[e;f]</code>로 양화한다. 그러나 <code class=\"language-text\">m</code>에 대해서는 양화를 하지 못한다. 따라서 이를 우리가 <code class=\"language-text\">with</code>로 지정해야 한다. 사실 어떤 경우에 적용이 되고, 어떤 경우에 적용되지 않는지는 모르겠다. <a href=\"https://coq.inria.fr/refman/proof-engine/tactics.html#coq:tacn.apply\">Coq의 공식 문서</a>를 참고.</p>\n<h2 id=\"inversion\"><a href=\"#inversion\" aria-label=\"inversion permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>inversion</h2>","frontmatter":{"title":"5. Tactics: 추가적인 증명의 기술들","date":"July 16, 2018"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/lf/5-tactics/","previous":null,"next":{"fields":{"slug":"/lf/3-lists/"},"frontmatter":{"title":"3. Lists: 배열 데이터 타입","category":"LF"}}}}