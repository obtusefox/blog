{"data":{"site":{"siteMetadata":{"title":"Bee starter","author":"[Your Name]","siteUrl":"https://gatsby-starter-bee.netlify.com","comment":{"disqusShortName":"","utterances":"JaeYeopHan/gatsby-starter-bee"},"sponsor":{"buyMeACoffeeId":"jbee"}}},"markdownRemark":{"id":"91ab355b-53cc-57f6-a370-e2cd72251d57","excerpt":"Proof by Induction  파일의 내용을 학습하자. Basics를 import하기 다음 장을 시작하기에 앞서 앞장에서 다룬 Basics를 컴파일하여 import할 필요가 있다. 윈도우에서는 coqIde에서의 컴파일이 동작하지 않는다. 고로 유닉스 환경에서, 해당 경로에서 bash 명령어로  를 실행하거나, 혹은 리눅스에서 실행한 coqIde에서 make를 실행하자. n = n+0의 증명 을 증명해보자. 그런데 simpl 단계에서 아무것도 되지 않는다. n의 case…","html":"<h2 id=\"proof-by-induction\"><a href=\"#proof-by-induction\" aria-label=\"proof by induction permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Proof by Induction</h2>\n<p><code class=\"language-text\">Induction.v</code> 파일의 내용을 학습하자.</p>\n<h3 id=\"basics를-import하기\"><a href=\"#basics%EB%A5%BC-import%ED%95%98%EA%B8%B0\" aria-label=\"basics를 import하기 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Basics를 import하기</h3>\n<p>다음 장을 시작하기에 앞서 앞장에서 다룬 Basics를 컴파일하여 import할 필요가 있다. 윈도우에서는 coqIde에서의 컴파일이 동작하지 않는다. 고로 유닉스 환경에서, 해당 경로에서 bash 명령어로 <code class=\"language-text\">make</code>를 실행하거나, 혹은 리눅스에서 실행한 coqIde에서 make를 실행하자.</p>\n<h3 id=\"n--n0의-증명\"><a href=\"#n--n0%EC%9D%98-%EC%A6%9D%EB%AA%85\" aria-label=\"n  n0의 증명 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>n = n+0의 증명</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Theorem plus_n_O_firsttry : forall n:nat,\n  n = n + 0.</code></pre></div>\n<p>을 증명해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Proof.\n  intros n.\n  simpl. (* Does nothing! *)\nAbort.</code></pre></div>\n<p>그런데 simpl 단계에서 아무것도 되지 않는다. n의 case에 따라 <code class=\"language-text\">+</code>가 simplified될 수 없기 때문에. 그럼 앞에서처럼 destruct를 써서 case를 나눠야 할까?</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Theorem plus_n_O_secondtry : forall n:nat,\n  n = n + 0.\nProof.\n  intros n. destruct n as [| n&#39;].\n  - (* n = 0 *)\n    reflexivity. (* so far so good... *)\n  - (* n = S n&#39; *)\n    simpl.       (* ...but here we are stuck again *)\nAbort.</code></pre></div>\n<p>마찬가지로 아무 일도 일어나지 않는다. 왜냐하면 두 번째 case에서 S(n’ + 0)이 나타나며 다시금 <code class=\"language-text\">simpl.</code>이 아무것도 할 수 없기 때문. 여기에서 induction을 도입한다. 귀납. 우리의 예시에선, 어떠한 <code class=\"language-text\">n</code>에 대하여 <code class=\"language-text\">n = n + 0</code>이 성립한다면 <code class=\"language-text\">S n</code>에 대해서도 마찬가지가 성립함을 보여야 한다. 그런데 <code class=\"language-text\">n = n + 0</code>을 이미 보였다면, <code class=\"language-text\">S (n + 0)</code>에서 <code class=\"language-text\">n + 0</code>을 <code class=\"language-text\">n</code>으로 <code class=\"language-text\">rewrite</code>할 수 있을 것이다. 코드로는 다음과 같이 쓴다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Theorem plus_n_O : forall n:nat, n = n + 0.\nProof.\n  intros n. induction n as [| n&#39; IHn&#39;].\n  - (* n = 0 *)    reflexivity.\n  - (* n = S n&#39; *) simpl. rewrite &lt;- IHn&#39;. reflexivity.  Qed.</code></pre></div>\n<p>IHn’은 귀납적 전제에 붙여주는 이름이다. 따라서 IHn’이 아니라 다른 이름이 되어도 괜찮다. <code class=\"language-text\">rewrite &lt;- IHn&#39;</code>를 통해 <code class=\"language-text\">n+0</code>을 <code class=\"language-text\">n</code>으로 대체한다. 그럼 위에서 해결되지 않던 <code class=\"language-text\">S (n&#39; + 0)</code>의 경우가 해결된다.\n다음 예시로, 모든 n에 대하여 <code class=\"language-text\">minus n n</code>이 <code class=\"language-text\">0</code>임을 증명하자. destruct를 쓰는 증명의 경우</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Proof.\n  intros n.\n  destruct n as [|n&#39;].\n  - reflexivity.\n  - simpl.</code></pre></div>\n<p>마찬가지로 <code class=\"language-text\">S n&#39;</code>에서 막힌다. 그렇기에 <code class=\"language-text\">induction</code>을 도입하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Proof.\n  induction n as [| n&#39; IHn&#39;].\n  - (* n = 0 *)\n    simpl. reflexivity.\n  - (* n = S n&#39; *)\n    simpl. rewrite -&gt; IHn&#39;. reflexivity.  Qed.</code></pre></div>\n<p>여기서 <code class=\"language-text\">intros</code>는 불필요하다. <code class=\"language-text\">induction</code>이 <code class=\"language-text\">intros</code>의 역할까지 해주기 때문이다.\n나머지 예제들은 천천히 여태껏 배운 tactic들을 써보면 된다. 다만 <code class=\"language-text\">rewrite</code>에서 화살표의 방향에 따라 다르게 적용된다는 점에 주의하자. 이제부터는 생각을 하며 증명을 해야 한다. 그리고, 앞에서 증명한 Theorem을 바탕으로, 예를 들어 <code class=\"language-text\">rewrite plus_n_O</code>과 같은 tactic을 사용해야 한다. <code class=\"language-text\">plus_comm</code>은 <code class=\"language-text\">plus_n_0</code>와 <code class=\"language-text\">plus_n_Sm</code>을 사용하자.</p>","frontmatter":{"title":"2. Induction: 귀납에 의한 증명","date":"July 16, 2018"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/lf/2-induction/","previous":{"fields":{"slug":"/lf/3-lists/"},"frontmatter":{"title":"3. Lists: 배열 데이터 타입","category":"LF"}},"next":{"fields":{"slug":"/development/third/"},"frontmatter":{"title":"Third Post","category":"development"}}}}